using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Owin;
using System.Web.Http;
using System.Web.Http.Description;
using Autofac;
using Autofac.Integration.WebApi;
using MediatR;
using Schlumberger.Avocet.WebAPI.Filters;
using Schlumberger.Avocet.WebAPI.Loggers;
using System.Web.Http.ExceptionHandling;
using Schlumberger.Avocet.WebAPI.Application;
using Schlumberger.Avocet.WebAPI.ExceptionHandling;
using Schlumberger.Avocet.WebAPI.Validators;
using Schlumberger.Avocet.WebAPI.Workspace;
using Swashbuckle.Application;
using Schlumberger.Avocet.WebAPI.Utilities;
using Swashbuckle.Swagger;
using System.Text.RegularExpressions;

// ReSharper disable CheckNamespace
// ReSharper disable ClassNeverInstantiated.Global

namespace Schlumberger.Avocet.WebAPI
{
   public class Startup
   {
      /// This code configures Web API.
      /// The Startup class is specified as a type parameter in the WebApp.Start method.
      public void Configuration(IAppBuilder appBuilder)
      {
         // Configure Web API for self-host & register routes. 
         HttpConfiguration config = new HttpConfiguration();
         config.MapHttpAttributeRoutes();
         config.Routes.MapHttpRoute(
                     name: "DefaultApi",
                     routeTemplate: "api/{controller}/{id}",
                     defaults: new { id = RouteParameter.Optional }
               );
         config.Filters.Add(new ValidateModelAttribute());

         // Build IOC container
         IContainer container = BuildIocContainer(config);

         // Set the dependency resolver to be Autofac.
         config.DependencyResolver = new AutofacWebApiDependencyResolver(container);

         // OWIN setup for Autofac
         appBuilder.UseAutofacMiddleware(container);

         // Make sure the Autofac lifetime scope is passed to Web API.
         appBuilder.UseAutofacWebApi(config);
         appBuilder.UseWebApi(config);

         DocumentationConfiguration(config);

         ILogger logger = container.Resolve<ILogger>();
         config.Services.Replace(typeof(IExceptionHandler), new APIExceptionHandler(logger));
         appBuilder.Use<ExceptionHandlerMiddleware>(logger).UseWebApi(config);

         appBuilder.UseWebApi(config);

         // Start up instance of IAM

         // read clean argument which prevents loading of saved workspaces
         object cleanArg;
         appBuilder.Properties.TryGetValue(Constants.PreventReloadingOfWorkspacesKey, out cleanArg);
         bool clean = Convert.ToBoolean(cleanArg.ToString());

         // read min number of IAM pool size
         object minIamArg;
         appBuilder.Properties.TryGetValue(Constants.PoolSizeLimitKey, out minIamArg);
         int minIamNumber = Convert.ToInt16(minIamArg);

         container.Resolve<IWorkspaceContainerManager>().Initialize(clean, minIamNumber);
      }

      /// <summary>
      /// Set up Swagger UI for the documentation.
      /// </summary>
      /// <param name="config"></param>
      private static void DocumentationConfiguration(HttpConfiguration config)
      {
         config.EnableSwagger(c =>
         {
            // Locate the API Documentation generated by the Schlumberger.Avocet.WebAPI project.
            string executingAssemblyPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);

            // Tell swagger to generate documentation based on the XML doc file output from MSBbuild
            if (executingAssemblyPath != null)
            {
               c.IncludeXmlComments(Path.Combine(executingAssemblyPath, "Web API Documentation.xml"));
               c.PrettyPrint();
            }

            c.SingleApiVersion("v1", Constants.ApiDocumentation.Title)
                .Description(Constants.ApiDocumentation.Description)
                .Contact(cc => cc
                .Name(Constants.ApiDocumentation.SupportTeamName)
                .Email(Constants.ApiDocumentation.SupportEmail));

            c.ResolveConflictingActions(apiDescriptions => apiDescriptions.First());



         }).EnableSwaggerUi(DocumentationUIConfiguration);
      }

      /// <summary>
      /// Configure the look of the Documentation.
      /// </summary>
      private static Action<SwaggerUiConfig> DocumentationUIConfiguration
      {
         get
         {
            return c =>
            {
               // Use the "DocumentTitle" option to change the Document title.
               // Very helpful when you have multiple Swagger pages open, to tell them apart.

               c.DocumentTitle("IAM Web Service");

               // Use the "InjectStylesheet" option to enrich the UI with one or more additional CSS stylesheets.
               // The file must be included in your project as an "Embedded Resource", and then the resource's
               // "Logical Name" is passed to the method as shown below.

               c.InjectStylesheet(Assembly.GetAssembly(typeof(Startup)), string.Format("{0}.{1}", typeof(Startup).Namespace, "Web API Documentation.css"));
            };
         }
      }

      private static IContainer BuildIocContainer(HttpConfiguration config)
      {
         ContainerBuilder containerBuilder = new ContainerBuilder();
         Assembly executingAssembly = Assembly.GetExecutingAssembly();

         RegisterIAMClasses(containerBuilder);

         // Register WebApiControllers
         containerBuilder.RegisterApiControllers(executingAssembly)
                         .InstancePerRequest()
                         .PropertiesAutowired();

         // Register filter provider for custom filters that need DI
         // Register filter for all ApiControllers
         containerBuilder.RegisterWebApiFilterProvider(config);
         containerBuilder.RegisterType<LoggingActionFilter>()
                         .AsWebApiActionFilterFor<ApiController>()
                         .InstancePerRequest();

         // Register Autofac Model Binder Provider  for custom filters that need DI.
         // containerBuilder.RegisterWebApiModelBinderProvider();

         // Register a logger service to be used by the controllers, filters & other middleware.
         containerBuilder.Register(c => new LoggerService()).As<ILogger>().InstancePerLifetimeScope();

         // Register any Autofac modules
         containerBuilder.RegisterAssemblyModules(executingAssembly);

         RegisterMediatorRouting(containerBuilder, executingAssembly);

         // Process registrations
         IContainer container = containerBuilder.Build();

         return container;
      }

      private static void RegisterIAMClasses(ContainerBuilder containerBuilder)
      {
         containerBuilder.RegisterType<WorkspaceContainer>()
           .As<IWorkspaceContainer>()
           .PropertiesAutowired();

         containerBuilder.RegisterType<ApplicationProcessProvider>()
           .As<IApplicationProcessProvider>();

         // A little bit of IOC magic is happening here.
         // Goal: WorkspaceContainerManager needs to dynamically create an ApplicationInstance without calling the NEW operator.
         // Solution!
         // http://autofaccn.readthedocs.io/en/latest/advanced/delegate-factories.html
         // ApplicationInstance has a very simple public delegate called factory which describes it's own constructor.
         // - delegate:    public delegate IApplicationInstance Factory(bool isApplicationHidden, Process process, IOutOfProcessServer server);
         // - constructor: public                   ApplicationInstance(bool isApplicationHidden, Process process, IOutOfProcessServer server)
         // Workspace Container Manager's (registered below) constructor requires ApplicationInstance.Factory which provides instances of ApplicationInstance
         // Autofac is smart enough to use that delegate signature to generate a factory which will provide a NEW ApplicationInstance.
         // Why doe we want to do this?  WCM needs to dyncamically create new ApplicationInstances on demand without caling "new ApplicationInstance(...)"
         // We want our Autofac ApplicationContainter to handle all the NEW stuff. By registering a delegate in this manner, our code
         // does NOT show any dependency on Autofac yet Autofac gives us a Factory for free.  
         // Outside of Startup.cs, the WebApi codebase doesn't care or now about Autofac.
         containerBuilder.RegisterType<ApplicationInstance>()
            .As<IApplicationInstance>();

         containerBuilder.RegisterType<WorkspaceContainerManager>()
           .As<IWorkspaceContainerManager>()
           .SingleInstance();

         containerBuilder.RegisterType<WorkplaceStateIOStreamer>()
           .As<IWorkplaceStateIOStreamer>()
           .SingleInstance();

         containerBuilder.RegisterType<WorkspaceValidator>()
           .As<IWorkspaceValidator>();

         containerBuilder.RegisterType<OutOfProcessServerProvider>()
            .As<IOutOfProcessServerProvider>()
            .SingleInstance();
      }

      private static void RegisterMediatorRouting(ContainerBuilder containerBuilder, Assembly executingAssembly)
      {
         // Register mediator itself
         // https://github.com/jbogard/MediatR/wiki
         containerBuilder
            .RegisterType<Mediator>()
            .As<IMediator>()
            .InstancePerLifetimeScope();

         // Register request handlers
         containerBuilder
            .Register<SingleInstanceFactory>(ctx =>
            {
               IComponentContext c = ctx.Resolve<IComponentContext>();
               return t =>
               {
                  object o;
                  return c.TryResolve(t, out o) ? o : null;
               };
            })
            .InstancePerLifetimeScope();

         // Register notification handlers
         containerBuilder
            .Register<MultiInstanceFactory>(ctx =>
            {
               IComponentContext c = ctx.Resolve<IComponentContext>();
               return t => (IEnumerable<object>)c.Resolve(typeof(IEnumerable<>).MakeGenericType(t));
            })
            .InstancePerLifetimeScope();

         // finally register our custom code (individually, or via assembly scanning)
         // - requests & handlers as transient, i.e. InstancePerDependency()
         // - pre/post-processors as scoped/per-request, i.e. InstancePerLifetimeScope()
         // - behaviors as transient, i.e. InstancePerDependency()
         containerBuilder.RegisterAssemblyTypes(executingAssembly).
            Where(t => t.Name.EndsWith("Handler")).
            AsImplementedInterfaces(); // via assembly scan

         //containerBuilder.RegisterAssemblyTypes(typeof(WorkspaceCreateHandler).GetTypeInfo().Assembly).AsImplementedInterfaces(); // via assembly scan
         //builder.RegisterType<MyHandler>().AsImplementedInterfaces().InstancePerDependency(); 
      }
   }
}