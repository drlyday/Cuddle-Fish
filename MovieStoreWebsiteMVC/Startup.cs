using Microsoft.Owin;
using Microsoft.Owin.Cors;
using Microsoft.Owin.Security.Cookies;
using Owin;
using Swashbuckle.Application;
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Web.Http;
using Swashbuckle.Swagger;
using System.Web.Http.Description;
using Newtonsoft.Json;
using System.Collections.Generic;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Converters;
using System.Net.Http.Formatting;
using System.Diagnostics;

[assembly: OwinStartupAttribute(typeof(aspnet5.Startup))]
namespace aspnet5
{
   public partial class Startup
   {
      public void Configuration(IAppBuilder app)
      {
         app.UseCors(CorsOptions.AllowAll);
         ConfigureAuth(app);

         // using https://app.pluralsight.com/player?course=owin-katana-understanding&author=chris-klug&name=owin-katana-understanding-m5&clip=1&mode=live
         app.UseCookieAuthentication(new CookieAuthenticationOptions()
         {
            AuthenticationType = "ApplicationCookie",
            LoginPath = new Microsoft.Owin.PathString("/Auth/LoginModel")
         });

         var config = new HttpConfiguration();

         //Use JSON friendly default settings
         var defaultSettings = new JsonSerializerSettings
         {
            Formatting = Formatting.Indented,
            ContractResolver = new LowercaseContractResolver(),
            //Converters = new List<JsonConverter> { new StringEnumConverter { CamelCaseText = false }, }
         };
         JsonConvert.DefaultSettings = () => { return defaultSettings; };

         //Specify JSON as the default media type
         config.Formatters.Clear();
         config.Formatters.Add(new JsonMediaTypeFormatter());
         config.Formatters.JsonFormatter.SerializerSettings = defaultSettings;

         var jsonFormatter = config.Formatters.JsonFormatter;
         // This next line is not required for it to work, but here for completeness - ignore data contracts.
         jsonFormatter.UseDataContractJsonSerializer = false;
         var settings = jsonFormatter.SerializerSettings;
         #if DEBUG
                  // Pretty json for developers.
                  settings.Formatting = Formatting.Indented;
         #else
                 settings.Formatting = Formatting.None;
         #endif
         settings.ContractResolver = new CamelCasePropertyNamesContractResolver();

         //Route all requests to the RootController by default
         config.Routes.MapHttpRoute("api", "Areas/{controller}/{id}", defaults: new { id = RouteParameter.Optional });
         config.MapHttpAttributeRoutes();

         //Tell swagger to generate documentation based on the XML doc file output from msbuild
         DocumentationConfiguration(config);

         app.UseWebApi(config);

      
         Process.Start("chrome.exe", string.Format("--incognito {0}", "http://localhost:52306/swagger/ui/index"));

      }


      /// <summary>
      /// Set up Swagger UI for the documentation.
      /// </summary>
      /// <param name="config"></param>
      private static void DocumentationConfiguration(HttpConfiguration config)
      {
         //http://www.robzhu.com/blog/2015/5/17/to-document-aspnet-rest-apis

         config.EnableSwagger(c =>
         {
            // Locate the API Documentation generated by the WebAPI project.
            //string executingAssemblyPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
            var baseDirectory = AppDomain.CurrentDomain.BaseDirectory;

            // Tell swagger to generate documentation based on the XML doc file output from MSBbuild
            if (baseDirectory != null)
            {
               c.IncludeXmlComments(Path.Combine(baseDirectory, "docs.xml"));
               c.OperationFilter<FormatXmlCommentProperties>();
               c.PrettyPrint();
            }

            c.SingleApiVersion("v1", "Movie Store Docs")
                .Description("Description")
                .Contact(cc => cc
                .Name("Dustin")
                .Email("dustin.lyday@gmail.com"));

            c.ResolveConflictingActions(apiDescriptions => apiDescriptions.First());

         }).EnableSwaggerUi(DocumentationUIConfiguration);
      }

      /// <summary>
      /// Configure the look of the Documentation.
      /// </summary>
      private static Action<SwaggerUiConfig> DocumentationUIConfiguration
      {
         get
         {
            return c =>
            {
            // Use the "DocumentTitle" option to change the Document title.
            // Very helpful when you have multiple Swagger pages open, to tell them apart.

            c.DocumentTitle("Movie Store Docs");

            // Use the "InjectStylesheet" option to enrich the UI with one or more additional CSS stylesheets.
            // The file must be included in your project as an "Embedded Resource", and then the resource's
            // "Logical Name" is passed to the method as shown below.

            c.InjectStylesheet(Assembly.GetAssembly(typeof(Startup)), string.Format("{0}.{1}", typeof(Startup).Namespace, "Web API Documentation.css"));
            };
         }
      }

      //FormatXmlCommentProperties.cs
      public class FormatXmlCommentProperties : IOperationFilter
      {
         public void Apply(Operation operation, SchemaRegistry schemaRegistry, ApiDescription apiDescription)
         {
            operation.description = Formatted(operation.description);
            operation.summary = Formatted(operation.summary);
         }
         private string Formatted(string text)
         {
            if (text == null) return null;

            // Strip out the whitespace that messes up the markdown in the xml comments,
            // but don't touch the whitespace in <code> blocks. Those get fixed below.
            string resultString = Regex.Replace(text, @"(^[ \t]+)(?![^<]*>|[^>]*<\/)", "", RegexOptions.Multiline);
            resultString = Regex.Replace(resultString, @"<code[^>]*>", "<pre>", RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Multiline);
            resultString = Regex.Replace(resultString, @"</code[^>]*>", "</pre>", RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Multiline);
            resultString = Regex.Replace(resultString, @"<!--", "", RegexOptions.Multiline);
            resultString = Regex.Replace(resultString, @"-->", "", RegexOptions.Multiline);

            try
            {
               string pattern = @"<pre\b[^>]*>(.*?)</pre>";

               foreach (Match match in Regex.Matches(resultString, pattern, RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Multiline))
               {
                  var formattedPreBlock = FormatPreBlock(match.Value);
                  resultString = resultString.Replace(match.Value, formattedPreBlock);
               }
               return resultString;
            }
            catch
            {
               // Something went wrong so just return the original resultString
               return resultString;
            }
         }

         private string FormatPreBlock(string preBlock)
         {
            // Split the <pre> block into multiple lines
            var linesArray = preBlock.Split('\n');
            if (linesArray.Length < 2)
            {
               return preBlock;
            }
            else
            {
               // Get the 1st line after the <pre>
               string line = linesArray[1];
               int lineLength = line.Length;
               string formattedLine = line.TrimStart(' ', '\t');
               int paddingLength = lineLength - formattedLine.Length;

               // Remove the padding from all of the lines in the <pre> block
               for (int i = 1; i < linesArray.Length - 1; i++)
               {
                  linesArray[i] = linesArray[i].Substring(paddingLength);
               }

               var formattedPreBlock = string.Join("", linesArray);
               return formattedPreBlock;
            }

         }
      }
      public class LowercaseContractResolver : DefaultContractResolver
      {
         protected override string ResolvePropertyName(string propertyName)
         {
            return propertyName.ToLower();
         }
      }
   }
}
